import os
import pandas as pd
from neo4j import GraphDatabase
import json

# Load CSV file
file_path = 'vulnID-difftext.csv'
data = pd.read_csv(file_path)

# Neo4j connection details
uri = "neo4j://beatty.unfiltered.seclab.cs.ucsb.edu:7689"  # Update with your Neo4j instance details
user = "neo4j"
password = "!!Shellphish!!"  # Update with your password

# Specify the folder to save the JSON files
output_folder = 'jsonFiles'

# Create the output folder if it doesn't exist
if not os.path.exists(output_folder):
    os.makedirs(output_folder)

# Function to query Neo4j
def fetch_graph_data(vulnerability_identifier, file_modification_id, driver):
    query = """
    MATCH (baseNode:VulnerabilityPatch {vulnerabilityIdentifier: $identifier}) 
    OPTIONAL MATCH (baseNode)-[relation1]-(oneEdgeAway)
    OPTIONAL MATCH (oneEdgeAway)-[relation2]-(twoEdgesAway)
    WHERE oneEdgeAway:FileModification AND id(oneEdgeAway) = $file_mod_id
    RETURN DISTINCT 
        id(baseNode) as baseNodeId, labels(baseNode) as baseNodeLabels, properties(baseNode) as baseNodeProps, 
        id(relation1) as relation1Id, startNode(relation1) as relation1Start, endNode(relation1) as relation1End, type(relation1) as relation1Type, properties(relation1) as relation1Props,
        id(oneEdgeAway) as oneEdgeAwayId, labels(oneEdgeAway) as oneEdgeAwayLabels, properties(oneEdgeAway) as oneEdgeAwayProps,
        id(relation2) as relation2Id, startNode(relation2) as relation2Start, endNode(relation2) as relation2End, type(relation2) as relation2Type, properties(relation2) as relation2Props,
        id(twoEdgesAway) as twoEdgesAwayId, labels(twoEdgesAway) as twoEdgesAwayLabels, properties(twoEdgesAway) as twoEdgesAwayProps
    """
    with driver.session() as session:
        result = session.run(query, identifier=vulnerability_identifier, file_mod_id=file_modification_id)
        records = result.data()

    processed_records = []
    for record in records:
        processed_record = {
            'baseNode': {
                'identity': record['baseNodeId'],
                'labels': record['baseNodeLabels'],
                'properties': record['baseNodeProps']
            },
            'relation1': {
                'identity': record['relation1Id'],
                'start': record['baseNodeId'],
                'end': record['oneEdgeAwayId'],
                'type': record['relation1Type'],
                'properties': record['relation1Props']
            } if record['relation1Id'] else None,
            'oneEdgeAway': {
                'identity': record['oneEdgeAwayId'],
                'labels': record['oneEdgeAwayLabels'],
                'properties': record['oneEdgeAwayProps']
            },
            'relation2': {
                'identity': record['relation2Id'],
                'start': record['oneEdgeAwayId'],
                'end': record['twoEdgesAwayId'],
                'type': record['relation2Type'],
                'properties': record['relation2Props']
            } if record['relation2Id'] else None,
            'twoEdgesAway': {
                'identity': record['twoEdgesAwayId'],
                'labels': record['twoEdgesAwayLabels'],
                'properties': record['twoEdgesAwayProps']
            }
        }
        processed_records.append(processed_record)

    return processed_records

# Function to remove duplicates from the result set
def remove_duplicates(records):
    seen = set()
    unique_records = []

    for record in records:
        record_tuple = tuple(sorted((key, json.dumps(value, sort_keys=True)) for key, value in record.items()))
        if record_tuple not in seen:
            seen.add(record_tuple)
            unique_records.append(record)

    return unique_records

# Function to append bracket number to keys
def append_bracket_number(records):
    final_list = []
    for i, record in enumerate(records):
        modified_record = {f"{key}_{i}": value for key, value in record.items()}
        final_list.append(modified_record)
    return final_list

# Function to save JSON to file
def save_to_json(data, filename):
    with open(filename, 'w') as file:
        json.dump(data, file, indent=4)

# Main function to process each identifier and download JSON
def main():
    driver = GraphDatabase.driver(uri, auth=(user, password))
    
    for index, row in data.iterrows():
        identifier = row['vulnerabilityIdentifier'].strip('"')  # Clean identifier
        file_mod_id = row['fileModificationId']
        records = fetch_graph_data(identifier, file_mod_id, driver)
        unique_records = remove_duplicates(records)
        modified_records = append_bracket_number(unique_records)
        filename = os.path.join(output_folder, f"{identifier}_filemod_{file_mod_id}.json")
        save_to_json(records, filename)
        print(f"Saved {filename}")

    driver.close()

if __name__ == "__main__":
    main()